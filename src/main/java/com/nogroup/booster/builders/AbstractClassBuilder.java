package com.nogroup.booster.builders;

import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import com.helger.jcodemodel.AbstractJClass;
import com.helger.jcodemodel.AbstractJType;
import com.helger.jcodemodel.EClassType;
import com.helger.jcodemodel.IJExpression;
import com.helger.jcodemodel.JAtom;
import com.helger.jcodemodel.JCodeModelException;
import com.helger.jcodemodel.JDefinedClass;
import com.helger.jcodemodel.JExpr;
import com.helger.jcodemodel.JFieldRef;
import com.helger.jcodemodel.JFieldVar;
import com.helger.jcodemodel.JInvocation;
import com.helger.jcodemodel.JMethod;
import com.helger.jcodemodel.JMod;
import com.helger.jcodemodel.JPackage;
import com.helger.jcodemodel.JTypeVar;
import com.helger.jcodemodel.JVar;
import com.nogroup.booster.codeModel.CodeModel;
import com.vaadin.flow.component.tabs.Tabs;

public abstract class AbstractClassBuilder extends AbstractFileBuilder{

	private CodeModel cm;
	private JDefinedClass cls;
	private boolean built = false ;

	public AbstractClassBuilder(CodeModel zm) {
		this.cm = zm ;
		cm.builders.add(this) ;
	}

	public CodeModel getCm() {
		return cm;
	}
	
	public void prebuild() throws JCodeModelException{
		this.cls = package_()._class(modifiers(), name(), type()) ;
		getCm().getClasses().put(name(), this.cls) ;
	}
	public void build()  {
		if(!built) {
			annotate(cls);
			javaDocFull(cls);
			
			extends_(cls);
			implements_(cls) ;
			buildConstants(cls);
			buildAttributes(cls) ;
			buildMethods(cls) ;
			buildDefaultMethods(cls);
			buildDelegatedMethods(cls) ;
			built = true;
		}
	}

	public JPackage package_() {
		Iterator<JPackage> its = cm.packages() ;
		while(its.hasNext()) {
			JPackage nxt = its.next() ;
			if(nxt.name().equals(packageName())) {
				return  nxt;
			}
		}
		return cm._package(packageName()) ;
		
	}
	
	public void javaDocFull(JDefinedClass cl) {
		cl.javadoc().add("Generated by DevBooster Module.\n");
		cl.javadoc().add("Developer   : medzied.arbi@gmail.com\n");
		cl.javadoc().add("Date        : " + new Date().toGMTString() + "\n");
		cl.javadoc().add("Archetype   : " + archetype() + "\n");
		javadoc(cl);
	}
	public abstract String archetype();
	public abstract String name() ;
	public abstract String packageName();
	public abstract EClassType type() ;
	public abstract int modifiers();
	public abstract void annotate(JDefinedClass cls) ;
	public abstract void javadoc(JDefinedClass cls);
	public abstract void buildConstants(JDefinedClass cls);
	public abstract void buildAttributes(JDefinedClass cls);
	public abstract void buildMethods(JDefinedClass cls);
	public abstract void buildDefaultMethods(JDefinedClass cls);
	public void buildDelegatedMethods(JDefinedClass cls) {
		
	}
	
	public abstract void extends_(JDefinedClass cls);
	public abstract void implements_(JDefinedClass cls);
	
	public static String capitalize(String s) {
		return (s.charAt(0) + "").toUpperCase() + s.substring(1) ;
	}
	
	public static String unCapitalize(String s) {
		return (s.charAt(0) + "").toLowerCase() + s.substring(1) ;
	}
	public static String amendSentence(String sstr) { 
        char[] str=sstr.toCharArray(); 
          
        String ss = "" ;
        // Traverse the string 
        for (int i=0; i < str.length; i++){    	
            if (str[i]>='A' && str[i]<='Z'){
                str[i] = (char)(str[i]+32); 
                if (i != 0) {
                	ss += "_" ;
                }
                ss += str[i]; 
            } 
            else {
            	ss += str[i]; 
            }
            
        } 
        return ss ;
    }    
	
	public void createGetter(JFieldVar var,JDefinedClass cl) {
		if(var.type().name().contains("_EC")) {
			JMethod getter = cl.method(
				JMod.PUBLIC, 
				getCm()._ref(List.class).boxify().narrow(getCm().resolve(var.type().name().replace("_EC", "_E"))), 
				"get" + capitalize(var.name())) ;
			getter.javadoc().add("Accessor Method for field " + var.name()) ;
			getter.body()._return(var) ;
		}else {
			
			if(var.type().name().equals("Boolean")) {
				JMethod getter = cl.method(JMod.PUBLIC, var.type(), "is" + capitalize(var.name())) ;
				getter.javadoc().add("Accessor Method for field " + var.name()) ;
				getter.body()._return(var) ;
			}else {
				JMethod getter = cl.method(JMod.PUBLIC, var.type(), "get" + capitalize(var.name())) ;
				getter.javadoc().add("Accessor Method for field " + var.name()) ;
				getter.body()._return(var) ;
			}
			
		}
	}
	
	public JMethod createSetter(JFieldVar var,JDefinedClass cl,boolean v) {
		JMethod setter = cl.method(JMod.PRIVATE, getCm().VOID, "set" + capitalize(var.name())) ;
		setter.javadoc().add("Mutator Method for field " + var.name()) ;
		setter.param(var.type(), "val") ;
		setter.body().directStatement("this." + var.name() + " = val ;") ;
		return setter;
	}
	
	public JMethod createSetter(JFieldVar var,JDefinedClass cl) {
		JMethod setter = cl.method(JMod.PUBLIC, getCm().VOID, "set" + capitalize(var.name())) ;
		setter.javadoc().add("Mutator Method for field " + var.name()) ;
		setter.param(var.type(), "val") ;
		setter.body().directStatement("this." + var.name() + " = val ;") ;
		return setter;
	}
	
	public void createObservableSetter(JFieldVar var,JDefinedClass cl) {
		JMethod setter = cl.method(JMod.PUBLIC, getCm().VOID, "set" + capitalize(var.name()) + "AndNotify") ;
		setter.javadoc().add("Observable Mutator Method for field " + var.name()) ;
		setter.param(var.type(), "val") ;
		setter.body().directStatement("this." + var.name() + " = val ;") ;
		setter.body().directStatement("setChanged();") ;
		setter.body().directStatement("notifyObservers(val);") ;
		
	    
	}
	public void createObservableWither(JFieldVar var,JDefinedClass cl) {
		JMethod wither = cl.method(JMod.PUBLIC, cl, "with" + capitalize(var.name()) + "AndNotify") ;
		wither.javadoc().add("Fluent Observable Builder Method for field " + var.name()) ;
		wither.param(var.type(), "val") ;
		wither.body().directStatement("this." + var.name() + " = val ;") ;
		wither.body().directStatement("setChanged();") ;
		wither.body().directStatement("notifyObservers(val);") ;
		wither.body()._return(JExpr._this()) ;
	}
	public void createWither(JFieldVar var,JDefinedClass cl) {
		JMethod wither = cl.method(JMod.PUBLIC, cl, "with" + capitalize(var.name())) ;
		wither.javadoc().add("Fluent Builder Method for field " + var.name()) ;
		wither.param(var.type(), "val") ;
		wither.body().directStatement("this." + var.name() + " = val ;") ;
		wither.body()._return(JExpr._this()) ;
	}
	
	public String camelCaseToUnderScore(String name) {
		String[] camelCaseWords = name.split("(?=[A-Z])");
		String ss = "" ;
		for(String tmp : camelCaseWords) {
			ss += tmp + "_" ;
		}
		ss = ss.substring(0,ss.length()-1) ;
		return ss;
	}
	
	public JVar declare(JDefinedClass cls, JMethod md, AbstractJType class1, String string) {
		return md.body().decl(class1, string,JExpr._new(class1)) ;
	}
	
	public JVar declare(int mod,JDefinedClass cls, JMethod md, Class<?> class1, String string) {
		return declare(mod,cls, md, getCm().ref(class1), string) ;
	}
	
	public JVar declare(int mod,JDefinedClass cls, JMethod md, AbstractJType class1, String string) {
		return md.body().decl(mod,class1, string,JExpr._new(class1)) ;
	}
	
	public JVar declare(JDefinedClass cls, JMethod md, AbstractJType class1, AbstractJType class2, String string) {
		return md.body().decl(class1, string,JExpr._new(class2)) ;
	}
	
	public void invokeSetter(JDefinedClass cls2, JMethod md, JVar fd, String string, String arg) {
		md.body().add(fd.invoke("set" + capitalize(string)).arg(arg)) ;
	}
	
	public void invokeSetter(JDefinedClass cls2, JMethod md, JVar fd, String string) {
		md.body().add(fd.invoke("set" + capitalize(string))) ;
	}
	
	public void invokeSetter(JDefinedClass cls2, JMethod md, JVar fd, String string, boolean arg) {
		md.body().add(fd.invoke("set" + capitalize(string)).arg(arg)) ;
	}
	
	public void invokeSetter(JDefinedClass cls, JMethod md, JVar fd, String string, JFieldRef arg) {
		md.body().add(fd.invoke("set" + capitalize(string)).arg(arg)) ;
	}
	public void invokeAdd(JDefinedClass cls, JMethod md, JVar fd, JInvocation _new) {
		md.body().add(fd.invoke("add").arg(_new)) ;
	}
	
	public void assignNew(JDefinedClass cls, JMethod md, JFieldRef ref, AbstractJClass ref2) {
		md.body().assign(ref, JExpr._new(ref2)) ;
	}
	
	public void invokeAdd(JDefinedClass cls, JMethod md, JVar fd, JFieldRef _new) {
		md.body().add(fd.invoke("add").arg(_new)) ;
	}
	
	public void invokeAdd(JDefinedClass cls, JMethod md, JVar fd, JVar _new) {
		md.body().add(fd.invoke("add").arg(_new)) ;
	}
	public JVar declare(JDefinedClass cls, JMethod md, Class<Tabs> class1, String string) {
		return declare(cls, md, getCm().ref(class1), string) ;
	}
	
	public AbstractJClass ref(Class<?> cls) {
		return getCm().ref(cls) ;
	}
	
	public JMethod bMethod(int mds, String sName,JAtom at) {
		JMethod md = cls.method(mds, Boolean.class, "is" + capitalize(sName)) ;
		md.body()._return(at) ;
		return md ;
	}
	
	public JMethod bOverridenMethod(int mds, String sName,JAtom at) {
		JMethod md = cls.method(mds, Boolean.class, "is" + capitalize(sName)) ;
		md.body()._return(at) ;
		md.annotate(Override.class) ;
		return md ;
	}
	
	public AbstractJClass refList(Class<?> cls) {
		return getCm().ref(List.class).narrow(cls) ;
	}
	
	public AbstractJClass refArrayList(Class<?> cls) {
		return getCm().ref(ArrayList.class).narrow(cls) ;
	}
	
	public AbstractJType resolve(String cls) {
		return getCm().resolve(cls) ;
	}

	public JFieldVar field(int nMods, AbstractJType aType, String sName) {
		return cls.field(nMods, aType, sName);
	}
	
	public JFieldVar priField(AbstractJType aType, String sName) {
		return cls.field(JMod.PRIVATE, aType, sName);
	}

	public JFieldVar field(int nMods, Class<?> aType, String sName) {
		return cls.field(nMods, aType, sName);
	}

	public JFieldVar field(int nMods, AbstractJType aType, String sName, IJExpression aInit) {
		return cls.field(nMods, aType, sName, aInit);
	}

	public JFieldVar field(int nMods, Class<?> aType, String sName, IJExpression aInit) {
		return cls.field(nMods, aType, sName, aInit);
	}

	public final JInvocation staticInvoke(JMethod aMethod) {
		return cls.staticInvoke(aMethod);
	}

	public final JInvocation staticInvoke(String sMethod) {
		return cls.staticInvoke(sMethod);
	}

	public final JFieldRef staticRef(String sField) {
		return cls.staticRef(sField);
	}

	public final JFieldRef staticRef(JVar aField) {
		return cls.staticRef(aField);
	}

	public JMethod method(int nMods, AbstractJType aType, String sName) {
		return cls.method(nMods, aType, sName);
	}

	public JMethod method(int nMods, Class<?> aType, String sName) {
		return cls.method(nMods, aType, sName);
	}

	public JTypeVar generify(String sName) {
		return cls.generify(sName);
	}

	public JTypeVar generify(String sName, Class<?> aBoundClass) {
		return cls.generify(sName, aBoundClass);
	}

	public JTypeVar generify(String sName, AbstractJClass aBoundClass) {
		return cls.generify(sName, aBoundClass);
	}
	
	public AbstractJClass refString() {
		return ref(String.class) ;
	}
	
	public JFieldRef jref(String ss) {
		return JExpr.ref(ss) ;
	}
}
